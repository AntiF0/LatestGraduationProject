/*!
  * vue-timer-hook v1.0.0
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */
import { computed, reactive, toRef, ref } from 'vue';

class Time {
    static getTimeFromSeconds(secs) {
        const totalSeconds = computed(() => Math.ceil(secs.value));
        const days = computed(() => Math.floor(totalSeconds.value / (60 * 60 * 24)));
        const hours = computed(() => Math.floor((totalSeconds.value % (60 * 60 * 24)) / (60 * 60)));
        const minutes = computed(() => Math.floor((totalSeconds.value % (60 * 60)) / 60));
        const seconds = computed(() => Math.floor(totalSeconds.value % 60));
        return {
            seconds,
            minutes,
            hours,
            days,
        };
    }
    static getSecondsFromExpiry(expiry, shouldRound) {
        const now = new Date().getTime();
        const milliSecondsDistance = expiry - now;
        if (milliSecondsDistance > 0) {
            const val = milliSecondsDistance / 1000;
            return shouldRound ? Math.round(val) : val;
        }
        return 0;
    }
    static getSecondsFromPrevTime(prevTime, shouldRound) {
        const now = new Date().getTime();
        const milliSecondsDistance = now - prevTime;
        if (milliSecondsDistance > 0) {
            const val = milliSecondsDistance / 1000;
            return shouldRound ? Math.round(val) : val;
        }
        return 0;
    }
    static getSecondsFromTimeNow() {
        const now = new Date();
        const currentTimestamp = now.getTime();
        const offset = now.getTimezoneOffset() * 60;
        return currentTimestamp / 1000 - offset;
    }
    static getFormattedTimeFromSeconds(totalSeconds, format) {
        const { seconds: secondsValue, minutes, hours, } = Time.getTimeFromSeconds(totalSeconds);
        const ampm = computed(() => format === '12-hour' ? (hours.value >= 12 ? 'pm' : 'am') : '');
        const hoursValue = computed(() => format === '12-hour' ? hours.value % 12 : hours.value);
        return {
            seconds: secondsValue,
            minutes,
            hours: hoursValue,
            ampm,
        };
    }
}

class Validate {
    static expiryTimestamp(expiryTimestamp) {
        const isValid = new Date(expiryTimestamp).getTime() > 0;
        if (!isValid) {
            console.warn('vue-timer-hook: { useTimer } Invalid expiryTimestamp settings', expiryTimestamp); // eslint-disable-line
        }
        return isValid;
    }
}

const isNumber = (val) => typeof val === 'number';
function useInterval(callback, ms) {
    let intervalId = undefined;
    const remove = () => {
        if (!intervalId)
            return;
        clearInterval(intervalId);
        intervalId = undefined;
    };
    const start = (_ms) => {
        remove();
        if (!_ms && !ms) {
            return;
        }
        const m = (_ms || ms);
        return (intervalId = setInterval(callback, m));
    };
    if (isNumber(ms)) {
        start();
    }
    return { remove, start };
}

// import { useState } from 'react';
const DEFAULT_DELAY = 1000;
function getDelayFromExpiryTimestamp(expiryTimestamp) {
    if (!Validate.expiryTimestamp(expiryTimestamp)) {
        return null;
    }
    const seconds = Time.getSecondsFromExpiry(expiryTimestamp);
    const extraMilliSeconds = Math.floor((seconds - Math.floor(seconds)) * 1000);
    return extraMilliSeconds > 0 ? extraMilliSeconds : DEFAULT_DELAY;
}
const useTimer = (expiry = 60, autoStart = true) => {
    let interval;
    const state = reactive({
        expiryTimestamp: expiry,
        seconds: Time.getSecondsFromExpiry(expiry),
        isRunning: autoStart,
        isExpired: false,
        didStart: autoStart,
        delay: getDelayFromExpiryTimestamp(expiry),
    });
    function _handleExpire() {
        state.isExpired = true;
        state.isRunning = false;
        state.delay = null;
        if (interval)
            interval.remove();
    }
    function pause() {
        state.isRunning = false;
        if (interval)
            interval.remove();
    }
    function restart(newExpiryTimestamp = expiry, newAutoStart = true) {
        pause();
        state.delay = getDelayFromExpiryTimestamp(newExpiryTimestamp);
        state.didStart = newAutoStart;
        state.isExpired = false;
        state.expiryTimestamp = newExpiryTimestamp;
        state.seconds = Time.getSecondsFromExpiry(newExpiryTimestamp);
        if (state.didStart)
            start();
    }
    function resume() {
        const time = new Date();
        const newExpiryTimestamp = time.setMilliseconds(time.getMilliseconds() + state.seconds * 1000);
        restart(newExpiryTimestamp);
    }
    function start() {
        if (state.didStart) {
            state.seconds = Time.getSecondsFromExpiry(state.expiryTimestamp);
            state.isRunning = true;
            interval = useInterval(() => {
                if (state.delay !== DEFAULT_DELAY) {
                    state.delay = DEFAULT_DELAY;
                }
                const secondsValue = Time.getSecondsFromExpiry(state.expiryTimestamp);
                state.seconds = secondsValue;
                if (secondsValue <= 0) {
                    _handleExpire();
                }
            }, state.isRunning ? state.delay : null);
        }
        else {
            resume();
        }
    }
    restart(expiry, autoStart);
    return {
        ...Time.getTimeFromSeconds(toRef(state, 'seconds')),
        start,
        pause,
        resume,
        restart,
        isRunning: toRef(state, 'isRunning'),
        isExpired: toRef(state, 'isExpired'),
    };
};

const epochSeconds = () => new Date().getTime();
const useStopwatch = (offsetTimestamp = 60, autoStart = true) => {
    let interval;
    const passedSeconds = ref(offsetTimestamp);
    const prevTime = ref(epochSeconds());
    const seconds = ref(passedSeconds.value + Time.getSecondsFromPrevTime(prevTime.value || 0, true));
    const isRunning = ref(autoStart);
    function start() {
        prevTime.value = epochSeconds();
        isRunning.value = true;
        seconds.value =
            passedSeconds.value + Time.getSecondsFromPrevTime(prevTime.value, true);
        interval = useInterval(() => {
            seconds.value =
                passedSeconds.value +
                    Time.getSecondsFromPrevTime(prevTime.value, true);
        }, isRunning.value ? 1000 : false);
    }
    function pause() {
        passedSeconds.value = seconds.value;
        isRunning.value = false;
        if (interval)
            interval.remove();
    }
    function reset(offset = 0, newAutoStart = true) {
        pause();
        isRunning.value = newAutoStart;
        passedSeconds.value = offset;
        seconds.value = +passedSeconds.value;
        Time.getSecondsFromPrevTime(prevTime.value, true);
        if (isRunning.value)
            start();
    }
    if (isRunning.value)
        start();
    return {
        ...Time.getTimeFromSeconds(seconds),
        start,
        pause,
        reset,
        isRunning,
    };
};

const useTime = (format = '24-hour') => {
    const seconds = ref(Time.getSecondsFromTimeNow());
    useInterval(() => {
        seconds.value = Time.getSecondsFromTimeNow();
    }, 1000);
    return {
        ...Time.getFormattedTimeFromSeconds(seconds, format),
    };
};

export { useStopwatch, useTime, useTimer };
